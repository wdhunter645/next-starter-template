name: Design Compliance (Warn)

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  pull-requests: write
  contents: read

jobs:
  design_compliance_warn:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Design Compliance Check
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Get PR details
            const prNumber = context.payload.pull_request.number;
            const prBody = context.payload.pull_request.body || '';
            
            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const changedFiles = files.map(f => f.filename);
            
            // Initialize findings
            const warnings = [];
            const passed = [];
            
            // ============================================================
            // Step 1: Validate PR template gates
            // ============================================================
            const requiredSections = [
              'MANDATORY FIRST STEP (ZIP SAFETY)',
              'DESIGN SOURCE OF TRUTH (NON-NEGOTIABLE)',
              'FILE-TOUCH ALLOWLIST (MANDATORY)',
              'VISUAL / UX INVARIANTS (MANDATORY)',
              'REQUIRED PRE-REVIEW SELF-CHECK'
            ];
            
            for (const section of requiredSections) {
              if (prBody.includes(section)) {
                passed.push(`âœ… Required section present: "${section}"`);
              } else {
                warnings.push(`âš ï¸ Missing required PR template section: "${section}"`);
              }
            }
            
            // ============================================================
            // Step 2: Validate ZIP safety statement
            // ============================================================
            const hasZipStatement = prBody.includes('No ZIP found in repo root') || 
                                    (prBody.includes('ZIP') && (prBody.includes('deleted') || prBody.includes('removed')));
            
            if (hasZipStatement) {
              passed.push('âœ… ZIP safety statement present');
            } else {
              warnings.push('âš ï¸ Missing ZIP safety statement: PR body must either state "No ZIP found in repo root" or confirm deletion of ZIP from repo root');
            }
            
            // ============================================================
            // Step 3: Parse file-touch allowlist from PR body
            // ============================================================
            let allowlist = [];
            let allowlistParsed = false;
            
            // Extract "Allowed files:" section
            const allowedFilesMatch = prBody.match(/Allowed files?:([\s\S]*?)(?=\n#+|Forbidden:|$)/i);
            
            if (allowedFilesMatch) {
              const allowedSection = allowedFilesMatch[1];
              // Extract bullet points (lines starting with - or *)
              const bulletRegex = /^[\s]*[-*]\s*`?([^`\n]+?)`?$/gm;
              let match;
              
              while ((match = bulletRegex.exec(allowedSection)) !== null) {
                const filepath = match[1].trim();
                // Skip empty lines and lines that are section headers
                if (filepath && filepath.length > 0 && !filepath.match(/^[A-Z][^:]*:$/)) {
                  allowlist.push(filepath);
                }
              }
              
              if (allowlist.length > 0) {
                allowlistParsed = true;
                passed.push(`âœ… File-touch allowlist parsed: ${allowlist.length} file(s)`);
              } else {
                warnings.push('âš ï¸ File-touch allowlist section found but is empty or unparseable');
              }
            } else {
              warnings.push('âš ï¸ File-touch allowlist section missing or unparseable (expected "Allowed files:" section)');
            }
            
            // ============================================================
            // Step 4: Compare changed files against allowlist
            // ============================================================
            if (allowlistParsed) {
              const outOfAllowlist = [];
              
              for (const file of changedFiles) {
                // Ignore the workflow file itself
                if (file === '.github/workflows/design-compliance-warn.yml') {
                  continue;
                }
                
                if (!allowlist.includes(file)) {
                  outOfAllowlist.push(file);
                }
              }
              
              if (outOfAllowlist.length === 0) {
                passed.push('âœ… All changed files are in the allowlist');
              } else {
                warnings.push(`âš ï¸ Changed files outside allowlist (${outOfAllowlist.length}):\n${outOfAllowlist.map(f => `  - ${f}`).join('\n')}`);
              }
            }
            
            // ============================================================
            // Step 5: Docs-change heuristic
            // ============================================================
            const isDocFile = (f) => {
              return f.startsWith('docs/') || 
                     f.endsWith('.md') || 
                     f.endsWith('.rst') || 
                     f.endsWith('.txt') ||
                     f.includes('/README') ||
                     f.includes('/CHANGELOG');
            };
            
            const codeFiles = changedFiles.filter(f => !isDocFile(f));
            const docFiles = changedFiles.filter(f => isDocFile(f));
            
            if (codeFiles.length > 0 && docFiles.length === 0) {
              warnings.push('âš ï¸ Code/config changed without docs updates (heuristic warning)');
            } else if (docFiles.length > 0) {
              passed.push('âœ… Documentation changes detected');
            }
            
            // ============================================================
            // Step 6: Generate outputs
            // ============================================================
            
            // Build job summary
            let summary = '## Design Compliance (Warn) â€” Findings\n\n';
            
            if (warnings.length === 0) {
              summary += '### âœ… All checks passed\n\n';
              summary += 'No design compliance warnings detected.\n\n';
            } else {
              summary += '### âš ï¸ Warnings Detected\n\n';
              summary += 'The following warnings were found. These are **informational only** and do not block the PR.\n\n';
              for (const warning of warnings) {
                summary += `${warning}\n\n`;
              }
              summary += '\n---\n\n';
              summary += '### Required Actions\n\n';
              summary += '1. Review warnings above\n';
              summary += '2. Update PR description to include required sections and allowlist\n';
              summary += '3. Ensure changed files match your documented allowlist\n';
              summary += '4. Resolve warnings before marking PR "Ready for Review"\n\n';
            }
            
            if (passed.length > 0) {
              summary += '### âœ… Passed Checks\n\n';
              for (const check of passed) {
                summary += `${check}\n\n`;
              }
            }
            
            summary += '\n---\n\n';
            summary += '**Note:** This check is informational only and does not block PR merges. ';
            summary += 'Warnings should be addressed before requesting review.\n';
            
            // Write job summary
            await core.summary
              .addRaw(summary)
              .write();
            
            // Build PR comment
            const commentMarker = '<!-- design-compliance-warn -->';
            let commentBody = commentMarker + '\n\n';
            commentBody += '## ðŸ” Design Compliance (Warn) â€” Findings\n\n';
            
            if (warnings.length === 0) {
              commentBody += '### âœ… All checks passed\n\n';
              commentBody += 'No design compliance warnings detected. Great work!\n';
            } else {
              commentBody += '> **Note:** This is an informational check only. Warnings do not block the PR.\n\n';
              commentBody += '### âš ï¸ Warnings\n\n';
              for (const warning of warnings) {
                commentBody += `${warning}\n\n`;
              }
              commentBody += '### ðŸ“‹ Next Steps\n\n';
              commentBody += '1. Review warnings above\n';
              commentBody += '2. Update PR description to include required template sections\n';
              commentBody += '3. Add file-touch allowlist under "Allowed files:" in PR body\n';
              commentBody += '4. Ensure all changed files are documented in allowlist\n';
              commentBody += '5. Resolve warnings before marking "Ready for Review"\n\n';
            }
            
            if (passed.length > 0) {
              commentBody += '<details>\n<summary>âœ… Passed Checks</summary>\n\n';
              for (const check of passed) {
                commentBody += `${check}\n\n`;
              }
              commentBody += '</details>\n\n';
            }
            
            commentBody += '---\n\n';
            commentBody += '*This check runs automatically on PR open/edit/sync. It helps ensure PRs follow the documented design process.*\n';
            
            // Post or update comment (idempotent)
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            
            const existingComment = comments.find(c => c.body?.includes(commentMarker));
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: commentBody,
              });
              console.log('Updated existing comment');
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: commentBody,
              });
              console.log('Created new comment');
            }
            
            // Always exit successfully (this is a warn-only check)
            console.log('Design compliance check completed successfully');
