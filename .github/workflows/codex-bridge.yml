name: codex-bridge
on:
  repository_dispatch:
    types: [codex-open-pr]
  workflow_dispatch:
    inputs:
      branch: {description: 'Branch to create/update', required: false, default: 'codex/bridge-pr'}
      base:   {description: 'Base branch', required: false, default: 'main'}
      file:   {description: 'File to touch under docs/**', required: false, default: 'docs/README.md'}
      append: {description: 'Line to append', required: false, default: 'Codex bridge test.'}
      title:  {description: 'PR title', required: false, default: 'codex: bridge PR'}
      body:   {description: 'PR body', required: false, default: 'Created by codex-bridge.'}
      trigger_docs_audit: {description: 'Also run docs-audit', required: false, default: 'true'}

permissions:
  contents: write
  pull-requests: write
  actions: write
  workflows: write

jobs:
  open_pr:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const p = context.payload.client_payload || {};
            const i = context.payload.inputs || {};
            const branch = p.branch || i.branch || 'codex/bridge-pr';
            const base   = p.base   || i.base   || 'main';
            const file   = p.file   || i.file   || 'docs/README.md';
            const append = p.append || i.append || 'Codex bridge test.';
            const title  = p.title  || i.title  || 'codex: bridge PR';
            const body   = p.body   || i.body   || 'Created by codex-bridge.';
            const triggerAudit = String(p.trigger_docs_audit ?? i.trigger_docs_audit ?? 'true') === 'true';

            const {owner, repo} = context.repo;
            const octo = github.getOctokit(process.env.GITHUB_TOKEN);

            const baseRef = await octo.rest.git.getRef({owner, repo, ref: `heads/${base}`});
            const baseSha = baseRef.data.object.sha;

            let exists = true;
            try { await octo.rest.git.getRef({owner, repo, ref: `heads/${branch}`}); }
            catch { exists = false; }
            if (!exists) await octo.rest.git.createRef({owner, repo, ref: `refs/heads/${branch}`, sha: baseSha});

            let sha, content = '';
            try {
              const r = await octo.rest.repos.getContent({owner, repo, path: file, ref: branch});
              sha = r.data.sha;
              content = Buffer.from(r.data.content, 'base64').toString();
            } catch (_) {}

            const next = (content.replace(/\s*$/,'') + `\n${append}\n`);
            await octo.rest.repos.createOrUpdateFileContents({
              owner, repo, path: file, branch,
              message: 'chore(docs): codex bridge update',
              content: Buffer.from(next).toString('base64'),
              sha
            });

            const prs = await octo.rest.pulls.list({owner, repo, state: 'open', head: `${owner}:${branch}`, base});
            if (prs.data.length === 0) {
              const pr = await octo.rest.pulls.create({owner, repo, head: branch, base, title, body});
              core.info(`Opened PR: ${pr.data.html_url}`);
            } else {
              core.info(`PR already open for ${branch}`);
            }

            if (triggerAudit) {
              try {
                await octo.rest.actions.createWorkflowDispatch({
                  owner, repo, workflow_id: 'docs-audit.yml', ref: branch
                });
                core.info('Triggered docs-audit workflow.');
              } catch (e) {
                core.warning(`docs-audit dispatch failed: ${e.message}`);
              }
            }
