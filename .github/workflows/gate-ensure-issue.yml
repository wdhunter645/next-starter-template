name: gate-ensure-issue

on:
  pull_request_target:
    types: [opened, reopened]

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  ensure-issue:
    runs-on: ubuntu-latest
    concurrency:
      group: gate-ensure-issue-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    steps:
      - name: Ensure PR references an Issue (auto-create if missing)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;

            const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

            const pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const body = pr.data.body || "";
            const title = pr.data.title || `PR #${prNumber}`;

            // Recognize an issue reference:
            // - Any URL containing "/issues/<number>"
            // - An "Issue:" line containing "#<number>"
            const issueUrlMatch = body.match(/https?:\/\/github\.com\/[\w.-]+\/[\w.-]+\/issues\/(\d+)/i);
            const issueHashMatch = body.match(/\bIssue\s*:\s*#(\d+)\b/i);

            if (issueUrlMatch || issueHashMatch) {
              core.info("Issue reference found in PR body; no action required.");
              return;
            }


            // Dedupe guard: ensure we only ever have ONE work-tracking Issue per PR.
            // Search for an existing Issue with a deterministic title key.
            const issueKey = `[Work][PR #${prNumber}]`;

            const findExisting = async (state) => {
              const q = `repo:${owner}/${repo} type:issue in:title "${issueKey}" state:${state}`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
              return (res.data.items || []).find(i => i.pull_request === undefined) || null;
            };

            let existingIssue = await findExisting("open");
            if (!existingIssue) {
              // If it exists but is closed (e.g., PR reopened), reopen it instead of creating a duplicate.
              const closed = await findExisting("closed");
              if (closed) {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: closed.number,
                  state: "open",
                });
                existingIssue = await findExisting("open");
              }
            }

            if (existingIssue) {
              const issueUrl = existingIssue.html_url;

              core.info(`Existing work-tracking Issue found: ${issueUrl}`);

              // Best-effort: update PR body to include Issue link near the top (idempotent).
              let newBody = body;
              if (body.match(/- \*\*Issue:\*\*/i)) {
                newBody = body.replace(/- \*\*Issue:\*\*.*$/im, `- **Issue:** ${issueUrl}`);
              } else {
                newBody = `- **Issue:** ${issueUrl}\n\n` + body;
              }

              try {
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: prNumber,
                  body: newBody,
                });
              } catch (e) {
                core.info("Unable to update PR body; existing Issue still linked by title key.");
              }

              return;
            }

            // Build Issue body from PR content (full PR template content preserved).
            const issueBody =
              `Auto-created work-tracking Issue for PR #${prNumber}.\n\n` +
              `PR: https://github.com/${owner}/${repo}/pull/${prNumber}\n\n` +
              `---\n\n` +
              `PR BODY (as submitted)\n\n` +
              body;

            // Retry issue creation (preferred), then fall back to a non-blocking PR comment.
            const maxAttempts = 3;
            let createdIssue = null;
            let lastError = null;

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              try {
                core.info(`Creating Issue (attempt ${attempt}/${maxAttempts})...`);
                const res = await github.rest.issues.create({
                  owner,
                  repo,
                  title: `[Work][PR #${prNumber}] ${title}`,
                  body: issueBody,
                });
                createdIssue = res.data;
                break;
              } catch (err) {
                lastError = err;
                core.warning(`Issue create failed on attempt ${attempt}: ${err.message || err}`);
                // Exponential-ish backoff: 10s, 20s, 30s
                await sleep(10000 * attempt);
              }
            }

            if (!createdIssue) {
              const msg =
                `⚠️ Repo automation tried to auto-create a work-tracking Issue for this PR but failed.\n\n` +
                `Error: ${lastError?.message || lastError}\n\n` +
                `Action required: create an Issue manually, then edit this PR to include the Issue link in the "Issue:" field at the top.\n\n` +
                `This does NOT block approvals or merge.`;

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: msg,
              });

              // Apply a PR label if it exists (non-fatal if missing)
              try {
                const labels = await github.rest.issues.listLabelsForRepo({ owner, repo, per_page: 100 });
                const names = new Set(labels.data.map(l => l.name));
                if (names.has("issue-create-failed")) {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number: prNumber,
                    labels: ["issue-create-failed"],
                  });
                }
              } catch (e) {
                core.info("Skipping PR label application (labels may be paginated or unavailable).");
              }

              return;
            }

            const issueUrl = createdIssue.html_url;

            // Apply Issue labels if they exist (non-fatal if missing)
            try {
              const labels = await github.rest.issues.listLabelsForRepo({ owner, repo, per_page: 100 });
              const names = new Set(labels.data.map(l => l.name));

              const issueLabels = [];
              if (names.has("work-accounting")) issueLabels.push("work-accounting");
              if (names.has("needs-triage")) issueLabels.push("needs-triage");

              if (issueLabels.length > 0) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: createdIssue.number,
                  labels: issueLabels,
                });
              }
            } catch (e) {
              core.info("Skipping Issue label application (labels may be paginated or unavailable).");
            }

            // Comment on PR with Issue link
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `✅ Work-tracking Issue auto-created: ${issueUrl}\n\nThe PR body has been updated to include the Issue link in the "Issue:" field.`,
            });

            // Best-effort: update PR body to include Issue link near the top
            let newBody = body;
            if (body.match(/- \*\*Issue:\*\*/i)) {
              // Replace placeholder line if present
              newBody = body.replace(/- \*\*Issue:\*\*.*$/im, `- **Issue:** ${issueUrl}`);
            } else {
              newBody = `- **Issue:** ${issueUrl}\n\n` + body;
            }

            try {
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: prNumber,
                body: newBody,
              });
            } catch (e) {
              core.info("Unable to update PR body; PR comment still provides the Issue link.");
            }